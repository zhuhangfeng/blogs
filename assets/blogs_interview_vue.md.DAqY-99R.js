import{j as s,b as i,c as a,a8 as n}from"./chunks/framework.DoFPn_w-.js";const y=JSON.parse('{"title":"interview-(vue)","description":"","frontmatter":{"title":"interview-(vue)","date":"2024-3-5","isShowComments":true,"categories":["interview"],"tags":["interview"],"sidebar":"auto"},"headers":[],"relativePath":"blogs/interview/vue.md","filePath":"blogs/interview/vue.md","lastUpdated":1714798971000}'),l={name:"blogs/interview/vue.md"},h=n(`<h1 id="interview-vue" tabindex="-1">interview-(vue) <a class="header-anchor" href="#interview-vue" aria-label="Permalink to &quot;interview-(vue)&quot;">​</a></h1><h2 id="mvvm-的理解" tabindex="-1">MVVM 的理解 <a class="header-anchor" href="#mvvm-的理解" aria-label="Permalink to &quot;MVVM 的理解&quot;">​</a></h2><p>MVVM 是一种前后端分离的设计模式，MVVM 分为 Model、View、ViewModel</p><ul><li>Model：数据模型层，数据和业务逻辑都在 Model 层中定义</li><li>View：视图层，负责数据的展示</li><li>ViewModel：视图模型层用于控制数据的改变和视图的更新</li></ul><h2 id="vue-和-react-的区别" tabindex="-1">vue 和 react 的区别 <a class="header-anchor" href="#vue-和-react-的区别" aria-label="Permalink to &quot;vue 和 react 的区别&quot;">​</a></h2><p>不同</p><ul><li>模板语法不同，react 采用 JSX 语法，vue 使用基于 HTML 的模板语法</li><li>数据绑定不同，vue 采用双向数据绑定，react 是单向数据绑定</li><li>状态管理不同，vue 采用 vuex 状态管理，react 使用 redux 状态管理</li><li>组件通信不同，</li><li>生命周期不同</li></ul><p>相同</p><ul><li>组件化开发</li><li>虚拟 DOM</li><li>响应式更新</li><li>集成能力</li></ul><h2 id="vue2-和-vue3-有哪些区别" tabindex="-1">Vue2 和 Vue3 有哪些区别 <a class="header-anchor" href="#vue2-和-vue3-有哪些区别" aria-label="Permalink to &quot;Vue2 和 Vue3 有哪些区别&quot;">​</a></h2><ul><li>vue2 使用的是 optionsApi，vue3 使用 composition API 组合式 API，更好的组织代码，提高代码可维护性</li><li>vue2 使用 Object.defineProperty 实现响应式原理，vue3 使用 Proxy 实现响应式原理更好的性能和更准确的数据变化追踪能力</li><li>vue3 引入了 Teleprot 组件，可以将 DOM 元素渲染到 DOM 数的其他位置，用于创建模态框、弹出框</li><li>Vue3 全局 API 名称发生改变，同时新增了 watchEffect、Hooks 等功能</li><li>vue3 对 TypeScript 的支持更加友好</li><li>vue3 核心库的依赖更少，减少打包体积</li></ul><h2 id="spa-的理解-有什么优点" tabindex="-1">SPA 的理解，有什么优点 <a class="header-anchor" href="#spa-的理解-有什么优点" aria-label="Permalink to &quot;SPA 的理解，有什么优点&quot;">​</a></h2><p>SPA（单页面应用）是一种前端应用程序的架构模式，加载应用程序是只加载一个 HTML 页面，通过使用 Javascript 动态地更新页面内容，从而实现无刷新的用户体验</p><p>优点</p><ul><li>用户体验好</li><li>代码复用率高</li><li>服务器负载较低</li></ul><p>缺点</p><ul><li>首次加载时间长</li><li>不利于 SEO 搜索引擎抓取</li></ul><h2 id="spa-和多页面有什么区别" tabindex="-1">SPA 和多页面有什么区别 <a class="header-anchor" href="#spa-和多页面有什么区别" aria-label="Permalink to &quot;SPA 和多页面有什么区别&quot;">​</a></h2><ul><li>页面加载方式：多页面应用每次导航需要重新加载整个页面，SPA 单页面无需重新加载整个页面</li><li>用户体验：SPA 提供了流程、快速的用户体验，因为页面切换时无需等待整个页面的重新加载，只有需要的数据和资源会被加载，减少了页面刷新的延迟。多页面应用则可能会有页面刷新的延迟，给用户带来较长的等待时间。</li><li>代码复用：SPA 采用组件化开发，在不同页面中复用组件，提高代码可维护性。多页面应用的每个页面都是独立的，组件复用的机会少</li><li>路由管理：在多页面应用中，页面之间的导航和路由由服务器处理，每个页面对应一个不同的 URL，而在 SPA 中，前端负责管理页面的导航和路由，通过前端路由库（如 Vue Router）来管理不同路径对应的组件</li><li>SEO：多页面比较有利，单页面由于是用 JavaScript 动态生成，不利于搜索引擎抓取</li></ul><h2 id="vue-的性能优化有哪些" tabindex="-1">vue 的性能优化有哪些 <a class="header-anchor" href="#vue-的性能优化有哪些" aria-label="Permalink to &quot;vue 的性能优化有哪些&quot;">​</a></h2><ul><li><p>编码阶段</p><ul><li>vue2 中 v-if 和 v-for 不能一起使用，因为 v-for 的优先级比 v-if 高，会造成性能浪费。vue3 中 v-if 的优先级比 v-for 高，也不能在一起使用，会报错</li><li>vue-for 保证 key 的唯一性</li><li>使用 keep-alive 缓存组件</li><li>v-if 和 v-show 酌情使用，v-if 直接不显示标签，而 v-show 是隐藏标签， v-show 适用于切换频率较高的场景</li><li>路由懒加载、异步组件</li><li>图片懒加载</li><li>节流:频繁触发变为少量触发，规定事件间隔内只执行一次</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;!--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 定时器版本 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> throttle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timer</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> context </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> args </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> arguments</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">timer){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            fn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context,args)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         },wait)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;!--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 时间戳版本 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> throttleTime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> context </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> args </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> arguments</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nowTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nowTime</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">wait){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         fn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context,args)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>防抖：多次触发变为一次触发，最后一次在规定时间后触发</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> debounce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">immediate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timer</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> args </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> arguments</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> context </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (timer) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">clearTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timer)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (immediate) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nowTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">timer</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }, wait)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (nowTime) fn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, args)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      fn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, args)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }, wait)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>第三方模块按需引入</li><li>服务端与渲染</li></ul></li><li><p>打包优化</p><ul><li>压缩代码</li><li>使用 CDN 加载第三方模块</li><li>抽离公共文件</li></ul></li><li><p>用户体验</p><ul><li>骨架屏</li><li>客户端缓存</li></ul></li><li><p>SEO 优化</p><ul><li>预渲染</li><li>服务端渲染</li><li>合理使用 meta 标签</li></ul></li></ul><h2 id="vue-生命周期" tabindex="-1">Vue 生命周期 <a class="header-anchor" href="#vue-生命周期" aria-label="Permalink to &quot;Vue 生命周期&quot;">​</a></h2><p>vue2：</p><ul><li>beforeCreate: 创建前，初始化事件和数据观测还未开始，不能访问 data、methods 中的数据和方法</li><li>created：创建后，实例初始化完成，可以访问 data 中的数据，但是渲染节点还未挂载到 DOM 上</li><li>beforeMount：挂载前，Vue 实例还未挂载到页面上</li><li>mounted：挂载后，vue 实例已经挂载完成，可以操作 DOM</li><li>beforeUpdate：更新前，数据已是最新的，但是还未更新到页面上</li><li>update：更新后，数据和页面都是最新的</li><li>beforDestorye：销毁前，还能获取到 data 中的数据</li><li>destoryed：销毁后，实例完全被销毁</li><li>activated：keep-alive 组件激活时调用（保持状态）</li></ul><p>vue3：</p><ul><li>setup：替代 vue2 中的 beforeCreate 和 created</li><li>onBeforeMount：挂载前，vue 实例还未挂载到页面</li><li>onMounted：挂载后，vue 实例已经挂载完成，可以操作 DOM</li><li>onBeforeUpdate：更新前数据已是最新的，但是还未更新到页面</li><li>onUpdated：更新后，页面和数据都是最新的</li><li>onBeforeUnmount：组件将要卸载时调</li><li>onUnmounted：组件已经卸载了</li><li>onActivated：缓存的组件被激活时调用</li></ul><h2 id="computed-和-watch-的区别" tabindex="-1">computed 和 watch 的区别 <a class="header-anchor" href="#computed-和-watch-的区别" aria-label="Permalink to &quot;computed 和 watch 的区别&quot;">​</a></h2><ul><li>computed：具有缓存功能，不支持异步，只有依赖的属性改变时才会重新计算，应用于需要依赖多个数据计算新值时，如过滤、排序</li><li>watch：不具备缓存功能，支持异步，一旦监听的数据发生变化，就会立即触发，应用于对数据进行复杂处理或执行异步操作，如网络请求</li></ul><h2 id="vue-组件通信" tabindex="-1">Vue 组件通信 <a class="header-anchor" href="#vue-组件通信" aria-label="Permalink to &quot;Vue 组件通信&quot;">​</a></h2><ul><li><p>父传子</p><ul><li>props</li><li>$chanildren</li><li>$refs</li></ul></li><li><p>子传父</p><ul><li>$emit</li><li>$parent</li><li>全局事件总线</li></ul></li><li><p>兄弟组件</p><ul><li>provied</li><li>inject</li><li>全局事件总线</li><li>vuex</li></ul></li></ul><h2 id="常见的事件修饰符及其作用" tabindex="-1">常见的事件修饰符及其作用 <a class="header-anchor" href="#常见的事件修饰符及其作用" aria-label="Permalink to &quot;常见的事件修饰符及其作用&quot;">​</a></h2><ul><li>.stop 阻止冒泡</li><li>.prevent 阻止默认事件</li><li>.capture 于事件冒泡的方向相反，事件捕获由外到内</li><li>.self 只会触发自己范围内的事件，不包含子元素</li><li>.one 只会触发一次</li></ul><h2 id="v-if-和-v-show-的区别" tabindex="-1">v-if 和 v-show 的区别 <a class="header-anchor" href="#v-if-和-v-show-的区别" aria-label="Permalink to &quot;v-if 和 v-show 的区别&quot;">​</a></h2><ul><li>v-if 是直接删除 DOM，消耗比较大，</li><li>v-show 是使用 display：none 控制显隐。切换频率较高时使用</li></ul><h2 id="v-html-的原理" tabindex="-1">v-html 的原理 <a class="header-anchor" href="#v-html-的原理" aria-label="Permalink to &quot;v-html 的原理&quot;">​</a></h2><p>会先移除节点下的所有节点，调用 html 方法，通过 addProp 添加 innerHTML 属性，归根结底还是设置 innerHtml 为 v-html 的值</p><h2 id="v-model-是如何实现的-语法糖实际是什么" tabindex="-1">v-model 是如何实现的，语法糖实际是什么 <a class="header-anchor" href="#v-model-是如何实现的-语法糖实际是什么" aria-label="Permalink to &quot;v-model 是如何实现的，语法糖实际是什么&quot;">​</a></h2><ul><li>当作用在表单上：通过 v-bind：value 绑定数据，v-on：input 来监听数据变化并修改 value，testValue = $event.target.value</li><li>当作用在组件上：本质上是父子通信语法糖，使用 prop 和$emit 实现</li></ul><h2 id="data-为什么是一个函数而不是对象" tabindex="-1">data 为什么是一个函数而不是对象 <a class="header-anchor" href="#data-为什么是一个函数而不是对象" aria-label="Permalink to &quot;data 为什么是一个函数而不是对象&quot;">​</a></h2><p>如果 data 是一个对象，就会造成多个组件引用同一个实例造成数据污染，如果是一个函数返回值，那每个组件都会有自己的私有数据空间，不会干扰其他组件的运行。</p><h2 id="mixin-和-mixins-区别" tabindex="-1">mixin 和 mixins 区别 <a class="header-anchor" href="#mixin-和-mixins-区别" aria-label="Permalink to &quot;mixin 和 mixins 区别&quot;">​</a></h2><ul><li>mixin 是全局混入，会影响到每个组件实例</li><li>mixins 是局部混入，哪个组件使用就引入哪个组件中</li><li>提高组件复用率</li><li>mixin 和组件发生冲突时 data 的属性和 methon 中的方法优先于 maxin</li><li>mixin 的生命周期优先于组件中执行</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个全局混入对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> globalMixin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  created</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;全局混入：组件创建时执行&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 全局混入</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mixin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(globalMixin)</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> localMixin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  methods: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    localMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;局部混入：自定义方法&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  mixins: [localMixin],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  methods: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    myMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;组件自身方法&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><h2 id="vue3-中不在使用-minx-而是是用-hooks" tabindex="-1">vue3 中不在使用 minx 而是是用 hooks <a class="header-anchor" href="#vue3-中不在使用-minx-而是是用-hooks" aria-label="Permalink to &quot;vue3 中不在使用 minx 而是是用 hooks&quot;">​</a></h2><p>hooks.js</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { onMounted, ref } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useCounter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  onMounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;组件已挂载，初始计数为:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, count.value)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> increment</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    count.value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    count,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    increment,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> useCounter</span></span></code></pre></div><p>组件中使用：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> useCounter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./useCounter&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">increment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useCounter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      count,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      increment,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="路由的-hash-和-history-模式的区别" tabindex="-1">路由的 hash 和 history 模式的区别 <a class="header-anchor" href="#路由的-hash-和-history-模式的区别" aria-label="Permalink to &quot;路由的 hash 和 history 模式的区别&quot;">​</a></h2><ul><li>hash：url 地址不带#号，通过 hashChange 事件监听 hash 变化，渲染不同的内容</li><li>history：使用 pushState 方法或者 replaceState 方法完成。history 需要服务器端配置，不然刷新会出现 404</li></ul><h2 id="router-和-route-的区别" tabindex="-1">router 和 route 的区别 <a class="header-anchor" href="#router-和-route-的区别" aria-label="Permalink to &quot;router 和 route 的区别&quot;">​</a></h2><ul><li>route 是路由信息，包括 path、params、query、name 等路由信息参数</li><li>router 是路由实例，包含路由跳转方法、钩子函数等</li></ul><h2 id="如何设置动态路由" tabindex="-1">如何设置动态路由 <a class="header-anchor" href="#如何设置动态路由" aria-label="Permalink to &quot;如何设置动态路由&quot;">​</a></h2><ul><li><p>params 传参</p><ul><li>路由配置：/index/:id</li><li>路由跳转：this.$router.push({name:&#39;index&#39;,params:{id:&quot;zs&quot;}})</li><li>路由参数获取：$route.params.id</li><li>最后形成的路由：/index/zs</li></ul></li><li><p>query 传参</p><ul><li>路由配置：/index</li><li>路由跳转：this.$router.push({path:&#39;index&#39;,query:{id:&#39;zs&#39;}})</li><li>最后形成的路由：/index?id=zs</li></ul></li></ul><h2 id="路由守卫" tabindex="-1">路由守卫 <a class="header-anchor" href="#路由守卫" aria-label="Permalink to &quot;路由守卫&quot;">​</a></h2><ul><li>全局前置钩子：beforeEach、beforeResolve，afterEach</li><li>路由独享守卫：beforeEnter</li><li>组件内钩子：beforeRouterEnter</li></ul><h2 id="vue-中-key-的作用" tabindex="-1">Vue 中 key 的作用 <a class="header-anchor" href="#vue-中-key-的作用" aria-label="Permalink to &quot;Vue 中 key 的作用&quot;">​</a></h2><p>更高效的更新虚拟 DOM，原理是 vue 在 patch 过程中通过 key 可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，减少 DOM 操作</p><h2 id="双向数据绑定的原理" tabindex="-1">双向数据绑定的原理 <a class="header-anchor" href="#双向数据绑定的原理" aria-label="Permalink to &quot;双向数据绑定的原理&quot;">​</a></h2><p>采用数据劫持结合发布者-订阅的方式。</p><ul><li>vue2 通过 Object.defineProperty 方法给每个值添加上一个 getter 和 setter，数据获取时触发 getter，数据改变时触发 setter</li><li>vue3 通过 Proxy 代理的方式比 vue2 更加完善，因为 vue2 的响应式只能监听到修改，不能监听到新增和删除，监听数组还要通过重写的方法才能手动更新</li></ul><h2 id="vue-是如何收集依赖的" tabindex="-1">vue 是如何收集依赖的 <a class="header-anchor" href="#vue-是如何收集依赖的" aria-label="Permalink to &quot;vue 是如何收集依赖的&quot;">​</a></h2><p>依赖收集发生在 defineReactive()方法中，在方法内 new Dep()实例化一个 Dep()实例，然后在 getter 中通过 dep.depend()方法对数据依赖进行收集，然后在 setter 中通过 dep.notify()通知更新</p><h2 id="slot-是什么" tabindex="-1">slot 是什么 <a class="header-anchor" href="#slot-是什么" aria-label="Permalink to &quot;slot 是什么&quot;">​</a></h2><p>一般在封装组件的时候使用，在组件内不知道以哪种形式来展示内容时可以用 slot 占位置。</p><ul><li>默认插槽 一个组件只有一个匿名插槽</li><li>具名插槽 一个组件可以有多个具名插槽</li><li>作用域插槽 可以将子组件内部的数据传递给父组件</li></ul><h2 id="keep-alive-的理解" tabindex="-1">keep-alive 的理解 <a class="header-anchor" href="#keep-alive-的理解" aria-label="Permalink to &quot;keep-alive 的理解&quot;">​</a></h2><p>用于缓存组件其中两个生命周期 actived、deactived 配合 keep-alive 使用，上一个呢是缓存组件被激活时触发，下一个是缓存组件被停用时触发</p><h2 id="nexttick" tabindex="-1">$nextTick <a class="header-anchor" href="#nexttick" aria-label="Permalink to &quot;\\$nextTick&quot;">​</a></h2><p>DOM 更新循环结束之后执行延迟回调</p><h2 id="vue-模板编译原理" tabindex="-1">vue 模板编译原理 <a class="header-anchor" href="#vue-模板编译原理" aria-label="Permalink to &quot;vue 模板编译原理&quot;">​</a></h2><p>将模板字符串解析成抽象语法树，然后生成可执行的渲染函数</p><ul><li>模板解析：将模板字符串解析成抽象语法树（AST）</li><li>优化：对 AST 进行静态节点标记，用于虚拟 DOM 的 patch 过程</li><li>代码生成：将 AST 编译生成可执行的 render 函数代码字符串</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 解析模板，生成AST</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ast</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(template)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 优化AST，标记静态节点</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  optimize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ast)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 编译AST，生成代码</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> code</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> generate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ast)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 返回render函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> code</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 解析逻辑，返回AST</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> optimize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ast</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 优化逻辑，标记静态节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> generate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ast</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 生成render函数代码</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> code </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`_c(&#39;div&#39;, {attrs: {&#39;id&#39;: &#39;app&#39;}})\`</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 根据AST生成更复杂的代码</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> code</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用compile函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> template</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\`</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> renderFunctionCode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(template)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 执行renderFunctionCode生成的代码...</span></span></code></pre></div>`,75),t=[h];function e(p,k,r,E,d,o){return i(),a("div",null,t)}const c=s(l,[["render",e]]);export{y as __pageData,c as default};
