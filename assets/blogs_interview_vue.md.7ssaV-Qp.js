import{j as i,b as s,c as a,a8 as l}from"./chunks/framework.DoFPn_w-.js";const c=JSON.parse('{"title":"interview-(vue)","description":"","frontmatter":{"title":"interview-(vue)","date":"2024-3-5","isShowComments":true,"categories":["interview"],"tags":["interview"],"sidebar":"auto"},"headers":[],"relativePath":"blogs/interview/vue.md","filePath":"blogs/interview/vue.md"}'),e={name:"blogs/interview/vue.md"},n=l(`<h1 id="interview-vue" tabindex="-1">interview-(vue) <a class="header-anchor" href="#interview-vue" aria-label="Permalink to &quot;interview-(vue)&quot;">​</a></h1><h2 id="mvvm的理解" tabindex="-1">MVVM的理解 <a class="header-anchor" href="#mvvm的理解" aria-label="Permalink to &quot;MVVM的理解&quot;">​</a></h2><p>MVVM是一种软甲架构模式，MVVM分为Model、View、ViewModel</p><ul><li>Model：数据模型层，数据和业务逻辑都在Model层中定义</li><li>View：视图层，负责数据的展示</li><li>ViewModel：视图模型层用于控制数据的改变和视图的更新</li></ul><h2 id="vue和react的区别" tabindex="-1">vue和react的区别 <a class="header-anchor" href="#vue和react的区别" aria-label="Permalink to &quot;vue和react的区别&quot;">​</a></h2><p>不同</p><ul><li>模板语法不同，react采用JSX语法，vue使用基于HTML的模板语法</li><li>数据绑定不同，vue采用双向数据绑定，react是单向数据绑定</li><li>状态管理不同，vue采用vuex状态管理，react使用redux状态管理</li><li>组件通信不同，</li><li>生命周期不同</li></ul><p>相同</p><ul><li>组件化开发</li><li>虚拟DOM</li><li>响应式更新</li><li>集成能力</li></ul><h2 id="vue2和vue3有哪些区别" tabindex="-1">Vue2和Vue3有哪些区别 <a class="header-anchor" href="#vue2和vue3有哪些区别" aria-label="Permalink to &quot;Vue2和Vue3有哪些区别&quot;">​</a></h2><ul><li>vue2使用的是optionsApi，vue3使用composition API组合式API，更好的组织代码，提高代码可维护性</li><li>vue2 使用Object.defineProperty实现响应式原理，vue3使用Proxy实现响应式原理更好的性能和更准确的数据变化追踪能力</li><li>vue3引入了Teleprot组件，可以将DOM元素渲染到DOM数的其他位置，用于创建模态框、弹出框</li><li>Vue3全局API名称发生改变，同时新增了watchEffect、Hooks等功能</li><li>vue3对TypeScript的支持更加友好</li><li>vue3核心库的依赖更少，减少打包体积</li></ul><h2 id="spa的理解-有什么优点" tabindex="-1">SPA的理解，有什么优点 <a class="header-anchor" href="#spa的理解-有什么优点" aria-label="Permalink to &quot;SPA的理解，有什么优点&quot;">​</a></h2><p>SPA（单页面应用）是一种前端应用程序的架构模式，加载应用程序是只加载一个HTML页面，通过使用Javascript动态地更新页面内容，从而实现无刷新的用户体验 优点</p><ul><li>用户体验好</li><li>代码复用率高</li><li>服务器负载较低 缺点</li><li>首次加载时间长</li><li>不利于SEO搜索引擎抓取</li></ul><h2 id="spa和多页面有什么区别" tabindex="-1">SPA和多页面有什么区别 <a class="header-anchor" href="#spa和多页面有什么区别" aria-label="Permalink to &quot;SPA和多页面有什么区别&quot;">​</a></h2><ul><li>页面加载方式：多页面应用每次导航需要重新加载整个页面，SPA单页面无需重新加载整个页面</li><li>用户体验：SPA提供了流程、快速的用户体验，因为页面切换时无需等待整个页面的重新加载，只有需要的数据和资源会被加载，减少了页面刷新的延迟。多页面应用则可能会有页面刷新的延迟，给用户带来较长的等待时间。</li><li>代码复用：SPA采用组件化开发，在不同页面中复用组件，提高代码可维护性。多页面应用的每个页面都是独立的，组件复用的机会少</li><li>路由管理：在多页面应用中，页面之间的导航和路由由服务器处理，每个页面对应一个不同的URL，而在SPA中，前端负责管理页面的导航和路由，通过前端路由库（如Vue Router）来管理不同路径对应的组件</li><li>SEO：多页面比较有利，单页面由于是用JavaScript动态生成，不利于搜索引擎抓取</li></ul><h2 id="vue的性能优化有哪些" tabindex="-1">vue的性能优化有哪些 <a class="header-anchor" href="#vue的性能优化有哪些" aria-label="Permalink to &quot;vue的性能优化有哪些&quot;">​</a></h2><ul><li><p>编码阶段</p><ul><li>vue2中v-if和v-for不能一起使用，因为v-for的优先级比v-if高，会造成性能浪费。vue3中v-if的优先级比v-for高，也不能在一起使用，会报错</li><li>vue-for 保证key的唯一性</li><li>使用keep-alive缓存组件</li><li>v-if和v-show酌情使用，v-if直接不显示标签，而v-show是隐藏标签， v-show适用于切换频率较高的场景</li><li>路由懒加载、异步组件</li><li>图片懒加载</li><li>节流:频繁触发变为少量触发，规定事件间隔内只执行一次</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;!--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 定时器版本 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> throttle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timer</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> context </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> args </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> arguments</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">timer){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            fn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context,args)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         },wait)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;!--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 时间戳版本 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> throttleTime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> context </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> args </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> arguments</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nowTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nowTime</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">wait){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         fn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context,args)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>防抖：多次触发变为一次触发，最后一次在规定时间后触发</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> debounce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">immediate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timer;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> args </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> arguments</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> context </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timer)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">clearTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timer)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(immediate){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nowTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">timer</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },wait)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nowTime)fn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context,args)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         fn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context,args)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },wait)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>第三方模块按需引入</li><li>服务端与渲染</li></ul></li><li><p>打包优化</p><ul><li>压缩代码</li><li>使用CDN加载第三方模块</li><li>抽离公共文件</li></ul></li><li><p>用户体验</p><ul><li>骨架屏</li><li>客户端缓存</li></ul></li><li><p>SEO优化</p><ul><li>预渲染</li><li>服务端渲染</li><li>合理使用meta标签</li></ul></li></ul><h2 id="vue生命周期" tabindex="-1">Vue生命周期 <a class="header-anchor" href="#vue生命周期" aria-label="Permalink to &quot;Vue生命周期&quot;">​</a></h2><p>vue2：</p><ul><li>beforeCreate: 创建前，初始化事件和数据观测还未开始，不能访问data、methods中的数据和方法</li><li>created：创建后，实例初始化完成，可以访问data中的数据，但是渲染节点还未挂载到DOM上</li><li>beforeMount：挂载前，Vue实例还未挂载到页面上</li><li>mounted：挂载后，vue实例已经挂载完成，可以操作DOM</li><li>beforeUpdate：更新前，数据已是最新的，但是还未更新到页面上</li><li>update：更新后，数据和页面都是最新的</li><li>beforDestorye：销毁前，还能获取到data中的数据</li><li>destoryed：销毁后，实例完全被销毁</li><li>activated：keep-alive组件激活时调用（保持状态）</li></ul><p>vue3：</p><ul><li>setup：替代vue2中的beforeCreate和created</li><li>onBeforeMount：挂载前，vue实例还未挂载到页面</li><li>onMounted：挂载后，vue实例已经挂载完成，可以操作DOM</li><li>onBeforeUpdate：更新前数据已是最新的，但是还未更新到页面</li><li>onUpdated：更新后，页面和数据都是最新的</li><li>onBeforeUnmount：组件将要卸载时调</li><li>onUnmounted：组件已经卸载了</li><li>onActivated：缓存的组件被激活时调用</li></ul><h2 id="computed和watch的区别" tabindex="-1">computed和watch的区别 <a class="header-anchor" href="#computed和watch的区别" aria-label="Permalink to &quot;computed和watch的区别&quot;">​</a></h2><ul><li>computed：具有缓存功能，不支持异步，只有依赖的属性改变时才会重新计算，应用于需要依赖多个数据计算新值时，如过滤、排序</li><li>watch：不具备缓存功能，支持异步，一旦监听的数据发生变化，就会立即触发，应用于对数据进行复杂处理或执行异步操作，如网络请求</li></ul><h2 id="vue组件通信" tabindex="-1">Vue组件通信 <a class="header-anchor" href="#vue组件通信" aria-label="Permalink to &quot;Vue组件通信&quot;">​</a></h2><ul><li><p>父传子</p><ul><li>props</li><li>$chanildren</li><li>$refs</li></ul></li><li><p>子传父</p><ul><li>$emit</li><li>$parent</li><li>全局事件总线</li></ul></li><li><p>兄弟组件</p><ul><li>provied</li><li>inject</li><li>全局事件总线</li><li>vuex</li></ul></li></ul><h2 id="常见的事件修饰符及其作用" tabindex="-1">常见的事件修饰符及其作用 <a class="header-anchor" href="#常见的事件修饰符及其作用" aria-label="Permalink to &quot;常见的事件修饰符及其作用&quot;">​</a></h2><ul><li>.stop 阻止冒泡</li><li>.prevent 阻止默认事件</li><li>.capture 于事件冒泡的方向相反，事件捕获由外到内</li><li>.self 只会触发自己范围内的事件，不包含子元素</li><li>.one 只会触发一次</li></ul><h2 id="v-if和v-show的区别" tabindex="-1">v-if和v-show的区别 <a class="header-anchor" href="#v-if和v-show的区别" aria-label="Permalink to &quot;v-if和v-show的区别&quot;">​</a></h2><ul><li>v-if是直接删除DOM，消耗比较大，</li><li>v-show是使用display：none控制显隐。切换频率较高时使用</li></ul><h2 id="v-html的原理" tabindex="-1">v-html的原理 <a class="header-anchor" href="#v-html的原理" aria-label="Permalink to &quot;v-html的原理&quot;">​</a></h2><p>会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHtml为v-html的值</p><h2 id="v-model是如何实现的-语法糖实际是什么" tabindex="-1">v-model是如何实现的，语法糖实际是什么 <a class="header-anchor" href="#v-model是如何实现的-语法糖实际是什么" aria-label="Permalink to &quot;v-model是如何实现的，语法糖实际是什么&quot;">​</a></h2><ul><li>当作用在表单上：通过v-bind：value绑定数据，v-on：input来监听数据变化并修改value，testValue = $event.target.value</li><li>当作用在组件上：本质上是父子通信语法糖，使用prop和$emit实现</li></ul><h2 id="data为什么是一个函数而不是对象" tabindex="-1">data为什么是一个函数而不是对象 <a class="header-anchor" href="#data为什么是一个函数而不是对象" aria-label="Permalink to &quot;data为什么是一个函数而不是对象&quot;">​</a></h2><p>如果data是一个对象，就会造成多个组件引用同一个实例造成数据污染，如果是一个函数返回值，那每个组件都会有自己的私有数据空间，不会干扰其他组件的运行。</p><h2 id="mixin和mixins区别" tabindex="-1">mixin和mixins区别 <a class="header-anchor" href="#mixin和mixins区别" aria-label="Permalink to &quot;mixin和mixins区别&quot;">​</a></h2><ul><li>mixin是全局混入，会影响到每个组件实例</li><li>mixins是局部混入，哪个组件使用就引入哪个组件中</li><li>提高组件复用率</li><li>mixin和组件发生冲突时data的属性和methon中的方法优先于maxin</li><li>mixin的生命周期优先于组件中执行</li></ul><h2 id="路由的hash和history模式的区别" tabindex="-1">路由的hash和history模式的区别 <a class="header-anchor" href="#路由的hash和history模式的区别" aria-label="Permalink to &quot;路由的hash和history模式的区别&quot;">​</a></h2><ul><li>hash：url地址不带#号，通过hashChange事件监听hash变化，渲染不同的内容</li><li>history：使用pushState方法或者replaceState方法完成。history需要服务器端配置，不然刷新会出现404</li></ul><h2 id="router和route的区别" tabindex="-1">router和route的区别 <a class="header-anchor" href="#router和route的区别" aria-label="Permalink to &quot;router和route的区别&quot;">​</a></h2><ul><li>route是路由信息，包括path、params、query、name等路由信息参数</li><li>router是路由实例，包含路由跳转方法、钩子函数等</li></ul><h2 id="如何设置动态路由" tabindex="-1">如何设置动态路由 <a class="header-anchor" href="#如何设置动态路由" aria-label="Permalink to &quot;如何设置动态路由&quot;">​</a></h2><ul><li><p>params传参</p><ul><li>路由配置：/index/:id</li><li>路由跳转：this.$router.push({name:&#39;index&#39;,params:{id:&quot;zs&quot;}})</li><li>路由参数获取：$route.params.id</li><li>最后形成的路由：/index/zs</li></ul></li><li><p>query传参</p><ul><li>路由配置：/index</li><li>路由跳转：this.$router.push({path:&#39;index&#39;,query:{id:&#39;zs&#39;}})</li><li>最后形成的路由：/index?id=zs</li></ul></li></ul><h2 id="路由守卫" tabindex="-1">路由守卫 <a class="header-anchor" href="#路由守卫" aria-label="Permalink to &quot;路由守卫&quot;">​</a></h2><ul><li>全局前置钩子：beforeEach、beforeResolve，afterEach</li><li>路由独享守卫：beforeEnter</li><li>组件内钩子：beforeRouterEnter</li></ul><h2 id="vue中key的作用" tabindex="-1">Vue中key的作用 <a class="header-anchor" href="#vue中key的作用" aria-label="Permalink to &quot;Vue中key的作用&quot;">​</a></h2><p>更高效的更新虚拟DOM，原理是vue在patch过程中通过key可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，减少DOM操作</p><h2 id="双向数据绑定的原理" tabindex="-1">双向数据绑定的原理 <a class="header-anchor" href="#双向数据绑定的原理" aria-label="Permalink to &quot;双向数据绑定的原理&quot;">​</a></h2><p>采用数据劫持结合发布者-订阅的方式。</p><ul><li>vue2 通过Object.defineProperty方法给每个值添加上一个getter和setter，数据获取时触发getter，数据改变时触发setter</li><li>vue3 通过Proxy代理的方式比vue2更加完善，因为vue2的响应式只能监听到修改，不能监听到新增和删除，监听数组还要通过重写的方法才能手动更新</li></ul><h2 id="vue是如何收集依赖的" tabindex="-1">vue是如何收集依赖的 <a class="header-anchor" href="#vue是如何收集依赖的" aria-label="Permalink to &quot;vue是如何收集依赖的&quot;">​</a></h2><p>依赖收集发生在defineReactive()方法中，在方法内new Dep()实例化一个Dep()实例，然后在getter中通过dep.depend()方法对数据依赖进行收集，然后在setter中通过dep.notify()通知更新</p><h2 id="slot是什么" tabindex="-1">slot是什么 <a class="header-anchor" href="#slot是什么" aria-label="Permalink to &quot;slot是什么&quot;">​</a></h2><p>一般在封装组件的时候使用，在组件内不知道以哪种形式来展示内容时可以用slot占位置。</p><ul><li>默认插槽 一个组件只有一个匿名插槽</li><li>具名插槽 一个组件可以有多个具名插槽</li><li>作用域插槽 可以将子组件内部的数据传递给父组件</li></ul><h2 id="keep-alive的理解" tabindex="-1">keep-alive的理解 <a class="header-anchor" href="#keep-alive的理解" aria-label="Permalink to &quot;keep-alive的理解&quot;">​</a></h2><p>用于缓存组件其中两个生命周期actived、deactived配合keep-alive使用，上一个呢是缓存组件被激活时触发，下一个是缓存组件被停用时触发</p><h2 id="nexttick" tabindex="-1">$nextTick <a class="header-anchor" href="#nexttick" aria-label="Permalink to &quot;$nextTick&quot;">​</a></h2><p>DOM更新循环结束之后执行延迟回调</p><h2 id="vue模板编译原理" tabindex="-1">vue模板编译原理 <a class="header-anchor" href="#vue模板编译原理" aria-label="Permalink to &quot;vue模板编译原理&quot;">​</a></h2><p>将模板字符串解析成抽象语法树，然后生成可执行的渲染函数</p><ul><li>模板解析，使用parese函数将模板解析字符串解析成AST</li><li>标记解析，使用optimize函数优化静态内容</li><li>生成render函数，使用generate函数创建render函数</li></ul>`,64),t=[n];function h(p,k,r,d,E,o){return s(),a("div",null,t)}const g=i(e,[["render",h]]);export{c as __pageData,g as default};
